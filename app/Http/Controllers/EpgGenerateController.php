<?php

namespace App\Http\Controllers;

use DOMDocument;
use XMLReader;
use App\Enums\ChannelLogoType;
use App\Enums\PlaylistChannelId;
use App\Models\Channel;
use App\Models\CustomPlaylist;
use App\Models\Epg;
use App\Models\MergedPlaylist;
use App\Models\Playlist;
use Carbon\Carbon;
use Filament\Notifications\Notification;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

class EpgGenerateController extends Controller
{
    /**
     * Generate the EPG XML file
     *
     * @param string $uuid
     * @return \Illuminate\Http\Response
     */
    public function __invoke(string $uuid)
    {
        // Fetch the playlist
        $playlist = Playlist::where('uuid', $uuid)->first();
        if (!$playlist) {
            $playlist = MergedPlaylist::where('uuid', $uuid)->first();
        }
        if (!$playlist) {
            $playlist = CustomPlaylist::where('uuid', $uuid)->firstOrFail();
        }

        // Generate a filename
        $filename = Str::slug($playlist->name) . '.xml';
        return response()->stream(
            fn() => $this->generate($playlist),
            200,
            [
                'Access-Control-Allow-Origin' => '*',
                'Content-Disposition' => "attachment; filename=$filename",
                'Content-Type' => 'application/xml'
            ]
        );
    }

    /**
     * Generate the EPG XML file and compress it
     *
     * @param string $uuid
     * @return \Illuminate\Http\Response
     */
    public function compressed(string $uuid)
    {
        // Fetch the playlist
        $playlist = Playlist::where('uuid', $uuid)->first();
        if (!$playlist) {
            $playlist = MergedPlaylist::where('uuid', $uuid)->first();
        }
        if (!$playlist) {
            $playlist = CustomPlaylist::where('uuid', $uuid)->firstOrFail();
        }

        // Generate a filename
        $filename = Str::slug($playlist->name) . '.xml.gz';

        // Start output buffering
        ob_start();

        // Generate the EPG content
        $this->generate($playlist);

        // Get the contents of the output buffer
        $content = ob_get_clean();

        // Compress the content
        $compressedContent = gzencode($content, 9);

        // Return the compressed content as a response
        return response($compressedContent, 200, [
            'Content-Type' => 'application/gzip',
            'Content-Disposition' => "attachment; filename=\"$filename\"",
            'Access-Control-Allow-Origin' => '*',
        ]);
    }

    /**
     * Generate the EPG XML file contents
     *
     * @param Playlist|MergedPlaylist|CustomPlaylist $playlist
     */
    private function generate($playlist)
    {
        // Output the XML header
        echo '<?xml version="1.0" encoding="UTF-8"?>
<tv generator-info-name="Generated by m3u editor" generator-info-url="' . url('') . '">';
        echo PHP_EOL;

        // Set up the channels
        $epgChannels = [];
        $dummyEpgChannels = [];
        $channels = $playlist->channels()
            ->where('enabled', true)
            ->orderBy('sort')
            ->orderBy('channel')
            ->orderBy('title')
            ->cursor();

        // Get playlist settings
        $channelNumber = $playlist->auto_channel_increment ? $playlist->channel_start - 1 : 0;
        $idChannelBy = $playlist->id_channel_by;
        $dummyEpgEnabled = $playlist->dummy_epg;
        $dummyEpgLength = (int)$playlist->dummy_epg_length ?? 120; // Default to 120 minutes if not set

        // Generate `<channel>` tags for each channel
        foreach ($channels as $channel) {
            // Get/set the channel number
            $channelNo = $channel->channel;
            if (!$channelNo && ($playlist->auto_channel_increment || $idChannelBy === PlaylistChannelId::ChannelId)) {
                $channelNo = ++$channelNumber;
            }

            // Get the `tvg-id` based on the playlist setting
            switch ($idChannelBy) {
                case PlaylistChannelId::ChannelId:
                    $tvgId = $channelNo;
                    break;
                case PlaylistChannelId::Name:
                    $tvgId = $channel->name_custom ?? $channel->name;
                    break;
                case PlaylistChannelId::Title:
                    $tvgId = $channel->title_custom ?? $channel->title;
                    break;
                default:
                    $tvgId = $channel->stream_id_custom ?? $channel->stream_id;
                    break;
            }

            // Make sure TVG ID only contains characters and numbers
            $tvgId = preg_replace(config('dev.tvgid.regex'), '', $tvgId);

            // Output the <channel> tag
            $title = $channel->title_custom ?? $channel->title;
            $title = htmlspecialchars($title);

            // Get the EPG channel data
            $epgData = $channel->epgChannel ?? null;

            // Output the <channel> tag
            if ($epgData) {
                // Keep track of which EPGs have which channels mapped
                // Need this to output the <programme> tags later
                if (!array_key_exists($epgData->epg_id, $epgChannels)) {
                    $epgChannels[$epgData->epg_id] = [];
                }
                $epgChannels[$epgData->epg_id][] = [$epgData->channel_id => $tvgId];

                // Get the icon
                $icon = '';
                if ($channel->logo_type === ChannelLogoType::Epg) {
                    $icon = $epgData->icon ?? '';
                } elseif ($channel->logo_type === ChannelLogoType::Channel) {
                    $icon = $channel->logo ?? '';
                }
                if (empty($icon)) {
                    $icon = url('/placeholder.png');
                }

                // Output the <channel> tag
                echo '  <channel id="' . $tvgId . '">' . PHP_EOL;
                echo '    <display-name lang="' . $epgData->lang . '">' . $title . '</display-name>';
                if ($channelNo !== null) {
                    echo '    <display-name>' . $channelNo . '</display-name>';
                }
                if ($icon) {
                    echo PHP_EOL . '    <icon src="' . htmlspecialchars($icon) . '"/>';
                }
                echo PHP_EOL . '  </channel>' . PHP_EOL;
            } else if ($dummyEpgEnabled) {
                // Get the icon
                $icon = $channel->logo ?? '';
                if (empty($icon)) {
                    $icon = url('/placeholder.png');
                }
                $icon = htmlspecialchars($icon);

                // Keep track of which channels need a dummy EPG program
                // Need this to output the <programme> tags later
                $dummyEpgChannels[] = [
                    'tvg_id' => $tvgId,
                    'channel_id' => $channel->id,
                    'channel_no' => $channelNo,
                    'title' => $title,
                    'icon' => $icon,
                    'group' => $channel->group ?? $channel->group_internal,
                    'include_category' => $playlist->dummy_epg_category,
                ];

                // Output the <channel> tag
                echo '  <channel id="' . $tvgId . '">' . PHP_EOL;
                echo '    <display-name>' . $title . '</display-name>';
                if ($channelNo !== null) {
                    echo PHP_EOL . '    <display-name>' . $channelNo . '</display-name>';
                }
                if ($icon) {
                    echo PHP_EOL . '    <icon src="' . $icon . '"/>';
                }
                echo PHP_EOL . '  </channel>' . PHP_EOL;
            }
        }

        // Fetch the EPGs (channels are keyed by EPG ID)
        $epgs = Epg::whereIn('id', array_keys($epgChannels))
            ->get();

        // Loop through the EPGs and output the <programme> tags
        foreach ($epgs as $epg) {
            // Channel data
            $channels = $epgChannels[$epg->id];

            // Skip if no channels
            if (!count($channels)) {
                continue;
            }

            // Get the content
            $filePath = null;
            if ($epg->url && str_starts_with($epg->url, 'http')) {
                $filePath = Storage::disk('local')->path($epg->file_path);
            } else if ($epg->uploads && Storage::disk('local')->exists($epg->uploads)) {
                $filePath = Storage::disk('local')->path($epg->uploads);
            } else if ($epg->url) {
                $filePath = $epg->url;
            }
            if (!$filePath) {
                // Send notification
                $error = "Invalid EPG file. Unable to read or download an associated EPG file. Please check the URL or uploaded file and try again.";
                Notification::make()
                    ->danger()
                    ->title("Error generating epg data for playlist \"{$playlist->name}\" using EPG \"{$epg->name}\"")
                    ->body($error)
                    ->broadcast($epg->user);
                Notification::make()
                    ->danger()
                    ->title("Error generating epg data for playlist \"{$playlist->name}\" using EPG \"{$epg->name}\"")
                    ->body($error)
                    ->sendToDatabase($epg->user);
                continue;
            }

            // Set up the reader
            $programReader = new XMLReader();
            $programReader->open('compress.zlib://' . $filePath);

            // Loop through the XML data
            while (@$programReader->read()) {
                // Only consider XML elements and programme nodes
                if ($programReader->nodeType == XMLReader::ELEMENT && $programReader->name === 'programme') {
                    // Get the channel id
                    $channelId = trim($programReader->getAttribute('channel'));
                    if (!$channelId) {
                        continue;
                    }

                    // EPG could be applied to multiple channels, find all matching channels
                    $filtered = array_filter($channels, fn($ch) => array_key_exists($channelId, $ch));
                    if (!count($filtered)) {
                        continue;
                    }
                    // Channel program found, output the <programme> tag
                    // First, we need to make sure the channel is correct
                    // Replace `channel="<channel_id>"` with `channel="<stream_id>"`
                    $itemDom = new DOMDocument();
                    $itemDom->loadXML($programReader->readOuterXML());

                    // Get the item element
                    $item = $itemDom->documentElement;
                    foreach ($filtered as $ch) {
                        // Modify the channel attribute
                        $item->setAttribute('channel', $ch[$channelId]);

                        // Output modified line
                        echo "  " . $itemDom->saveXML($item) . PHP_EOL;
                    }
                }
            }
            // Close the XMLReader for this epg
            $programReader->close();
        }

        // If dummy EPG channels, generate dummy programmes
        if (count($dummyEpgChannels) > 0) {
            foreach ($dummyEpgChannels as $dummyEpgChannel) {
                $tvgId = $dummyEpgChannel['tvg_id'];
                $title = $dummyEpgChannel['title'];
                $icon = $dummyEpgChannel['icon'];
                $channelNo = $dummyEpgChannel['channel_no'];
                $group = $dummyEpgChannel['group'];
                $includeCategory = $dummyEpgChannel['include_category'];

                // Generate dummy programmes for the specified length
                $startTime = Carbon::now()
                    ->startOf('day')
                    ->subMinutes($dummyEpgLength);

                // Generate 5 days worth of EPG data, based on the `$dummyEpgLength`, which is how long the programme should last in minutes
                for ($i = 0; $i < (5 * 24 * 60) / $dummyEpgLength; $i++) {
                    $startTime->addMinutes($dummyEpgLength);
                    $endTime = clone $startTime;
                    $endTime->addMinutes($dummyEpgLength);

                    // Format the start and end times
                    $start = str_replace(':', '', $startTime->format('YmdHis P'));
                    $end = str_replace(':', '', $endTime->format('YmdHis P'));

                    // Output the <programme> tag
                    echo '  <programme channel="' . $tvgId . '" start="' . $start . '" stop="' . $end . '">' . PHP_EOL;
                    echo '    <title>' . $title . '</title>' . PHP_EOL;
                    if ($icon) {
                        echo '    <icon src="' . $icon . '"/>' . PHP_EOL;
                    }
                    echo '    <desc>' . $title . '</desc>' . PHP_EOL;
                    if ($includeCategory) {
                        echo '    <category lang="en">' . $group . '</category>' . PHP_EOL;
                    }
                    echo '  </programme>' . PHP_EOL;
                }
            }
        }

        // Close it out
        echo '</tv>';
    }

    /**
     * Gzip the file
     *
     * @param string $filename
     * @param string $disk
     * @param bool $delete_original
     * @return bool
     */
    private function gzip($filename, $disk = 'local', $delete_original = false)
    {
        $disk = Storage::disk($disk);
        $data = $disk->get($filename);
        $out_file = "$filename.gz";

        $gzdata = gzencode($data, 9);
        $disk->put($out_file, $gzdata);
        $fp = fopen($disk->path($out_file), "w");
        $result = fwrite($fp, $gzdata);
        fclose($fp);

        if ($result && $delete_original) {
            $disk->delete($filename);
        }

        return $result > 0;
    }
}
